from datetime import datetime


MAIN_PROMPT = '''
###Користувач надасть тобі вхідний текст.
Твоє завдання розпарсити його. Визнач чи згадані в тексті наступні поля:###
"""
*currency - валюта (лише гривня(за замовчуванням)/долар/євро, інакше - "") = STRING 
*amount - визнач чи вказана сума грошей в тексті й поверни це значення. Це може бути просто число (без прив'язки до валюти). Валюта може бути недійсною, але якщо сума присутня, поверни її. (наприклад 17 гривень, 12 доларів) = FLOAT (.2f)
*description - опис покупки (зроби короткий опис покупки) = STRING 
"""

###Видай у відповідь JSON у вигляді. Якщо поле відсутнє в тексті, або хибне, поверни "". Якщо відсутня ціна покупки, поверни amount 0.0.
Опис повинен бути логічним. Якщо таких слів не існує, спробуй зрозуміти про що йшла мова з контексту або чи є англомовний термін й напиши коректний description. Не додавай назву бізнесу ###

###Приклад тексту:###
"Купила вчора шапку в АТБ за 17 гривень 12 копійок"

###Приклад відповіді:###
{
"currency": "гривня",
"amount": 17.12,
"description": "Купівля шапки",
}

###Розпарси текст в JSON файл згідно вимог. Повертай ВИКЛЮЧНО json файл у визначеному форматі і нічого більше (це важливо)!###
'''

BUSINESS_PROMPT = '''
###Користувач надасть тобі вхідний текст.
Твоє завдання провести Named Entity Recognition (NER) над текстом, а саме визначити назву бізнесу.
Якщо в тексті немає назви бізнесу, поверни "", не вигадуй його.

Приклад тексту: "Купив в макарон продукти на 730 гривень".
У даному прикладі назву бізнесу - "макарон", а куплено було продукти харвчування.

Ще приклад: "Купила в рошені цукерки"ю
У даному прикладі назву бізнесу - "рошені", а куплено було цукерки.

Твоє завдання повернути JSON файл.
JSON файл повинен мати наступний формат:
{{"business": назва бізнесу,
"language": визнач мову назви бізнесу (пріоритет українська при латиниці), ISO 639-1;
"uk_lemma": лема від назви (лише якщо бізнес українською). Зрозумій про що йдеться в бізнесі й утвори лему (наприклад, "мальовничому краї " -> "мальовничий край"),
"translation": переклад назви на українську або англійську, залежно від визначеної мови. Не вигадуй переклади, якщо немає такого - залиш порожнім,
"phonetic": фонетичний аналог вимови англійською, якщо бізнес українською й існує аналог по звучанню у англійській мові.
}}


Якщо не вдалося визначити назву бізнесу, поверни усі поля JSON значень порожніми "".

Приклад визначеного NER бізнесу: "вайтфокс"
{{"business": "вайтфокс",
"language":"uk"
"uk_lemma": "вайтфокс",
"translation": "",
"phonetic": "white fox"
}}

Інший приклад: "Ходив по квіти в синю квітку й купив троянди на 800 гривень"
Бізнес - "синю квітку"
{{"business": "синю квітку",
"language":"uk"
"uk_lemma": "синя квітка",
"translation": "black flower",
"phonetic": ""
}}

"купили у black box шафу"
{{"business": "black box",
"language":"en"
"uk_lemma": "",
"translation": "чорна скринька",
"phonetic": ""
}}

"купили в тейсті чікені дві курки гриль"
{{"business": тейсті чікені",
"language":"uk"
"uk_lemma": "тейсті чікен",
"translation": "",
"phonetic": "tasty chicken"
}}

Зауваження: бізнес часто може згадуватись після "в" та "у", але можуть бути винятки. Шукай слова які пояснюють ДЕ САМЕ була здійснена дія.
Це може бути й власною назвою (наприклад, Вінстон Черчілль), з відповіддю на граматичне питання "де?" (наприклад, "у Вінстоні Черчіллі")
Результат повинен бути логічним. Повертай виключно вказаний JSON.
'''


def make_categories_prompt(categories):
    prompt = f'''
    ###Користувач надасть тобі вхідний текст.
    Твоє завдання розпарсити його. Визнач чи релевантний текст одній з категорій покупок. Необіхідно повернути наступне поле:###
    *categoryId - "id" найбільш релевантної категорії покупки з розділу ДОСТУПНІ КАТЕГОРІЇ відповідно до тексту = INT

    ###ОПИС###
    Категорії йдуть у форматі "CategoryName": [(id, child_category), (id, child_category)]. Твоє завдання знайти (якщо така існує) найбільш релевантну дочірню категорію до вхідного тексту.
    Будь впевненим в категорії. Якщо не підходить жодна (або текст не пов'язаний жодним чином з покупками) - поверни  {{"categoryId":None}}

    ###ДОСТУПНІ КАТЕГОРІЇ:###
    {categories}

    ###Формат відповіді:###

    {{"categoryId":int}}

    ###Розпарси текст в JSON файл згідно вимог. Повертай ВИКЛЮЧНО json файл у визначеному форматі і нічого більше (це важливо)!###
    '''

    return prompt


def make_labels_prompt(labels):
    prompt = f'''
    ###Користувач надасть тобі вхідний текст.
    Твоє завдання розпарсити його. Визнач серед списку доступних міток найбільш релевантні. Необіхідно повернути наступне поле:###
    *labelsId - список "id" найбільш релевантних категорій покупки з розділу ДОСТУПНІ МІТКИ відповідно до тексту = LIST of INT

    ###ОПИС###
    Мітки (labels) йдуть у форматі [{{"id":id,"name":"name"}},{{"id":id,"name":"name"}}]

    ###ДОСТУПНІ МІТКИ:###
    {labels}

    ###Формат відповіді:###

    {{"labelsId":[int, int, int...]}}

    ###Якщо жодна мітка не підходить, або немає жодної з ДОСТУПНІ МІТКИ, поверни {{"labelsId":[]}}###

    Наприклад, підписка на нетфлікс може мати мітку "розваги", "підписки", "дозвілля"

    ###Розпарси текст в JSON файл згідно вимог. Повертай ВИКЛЮЧНО json файл у визначеному форматі і нічого більше (це важливо)!###
    '''

    return prompt


def make_accounts_prompt(accounts):
    data_example = [
        {
            "id": 52,
            "name": "Test",
            "provider": {
                "id": 1,
                "name": "Monobank",
                "nameEn": "Monobank"
            }
        },
        {
            "id": 55,
            "name": "Універсальна",
            "provider": {
                "id": 1,
                "name": "ПриватБанк",
                "nameEn": "PrivatBank"
            }
        },
        {
            "id": 152,
            "name": "Для виплат",
            "provider": {
                "id": 1,
                "name": "ПриватБанк",
                "nameEn": "PrivatBank"
            }
        },
    ]    

    prompt = f'''
    ###Користувач надасть тобі вхідний текст.
    Твоє завдання розпарсити його. Необіхідно повернути наступне поле:###
    *accountId - id найбільш релевантної банківської карти (рахунку) з розділу ###ДОСТУПНІ РАХУНКИ### відповідно до тексту = INT
    
    ###Приклад рахунків:###
    {data_example}


    ###Опис:###
    Кожен рахунок (при наявності) містить 'id' рахунку, назву, а також ім'я provider українською та англійською.
    Важливі усі ці дані для прийняття рішення.


    ###Користувач може називати скорочені варіанти назви provider замість повної. Наприклад "моно" замість "Monobank", або "аваль" замість "райфайзен банк аваль"###
    #### **Мапінг скорочень банків:** ####
    - Monobank: "Mono", "Моно", "Монобанк", "Монобанку", "Монобанка", "Монобанкової"
    - PrivatBank: "Приват", "ПриватБанк", "Privat", "Привата", "Привату", "Приватової"
    - Raiffeisen Bank Aval: "Аваль", "Райф", "Райффайзен", "Авалю", "Авалевої"

    #### **Мапінг скорочень назв карток/рахунків:** ####

    #### **Приклад роботи:** ####
    - Вхідний текст: `"Купив з універсальної карти ПриватБанку"`
    - Відповідь: `{{"accountId": 55}}` (збіг за "універсальна" (name) та "ПриватБанк") provider)

    - Вхідний текст: `"Купила з моно на 200 гривень продуктів"`
    - Відповідь: `{{"accountId": 52}}` (збіг за "моно" → "Monobank", без конкретної назви рахунку)

    Якщо акаунт не знайдено - поверни {{"accountId":None}}
    ###Формат відповіді:###
    {{"accountId":int}}

    Не використовуй приклад рахунків вище для визначення accountId. Виключно ДОСТУПНІ РАХУНКИ нижче!
    ###ДОСТУПНІ РАХУНКИ серед яких потрібно здійснити пошук:###
    {accounts}

    ###Розпарси текст в JSON файл згідно вимог. Повертай ВИКЛЮЧНО json файл у визначеному форматі і нічого більше (це важливо)!###
    '''

    return prompt


def make_datetime(time=datetime.now().isoformat()):
    prompt = f'''
    ### Користувач надасть тобі вхідний текст. Твоє завдання визначити коли відбулась описана користувачем подія###

    ###Поточний час (ISO 8601):###
    {time}

    ###Якщо не вдалось визначити час події, поверни поточний час:###
    {{"time": str({time}),
    "action": null,
    "years": null,
    "months": null,
    "days": null,
    "hours": null,
    "minutes":null}}

    ###Якщо користувач вказав "о (або в) *конкретний час*###:
    {{"time": str(час_події),
    "action": null,
    "years": null,
    "months": null,
    "days": null,
    "hours": null,
    "minutes":null}}
    
    Якщо просто вказівник часу "вчора", "сьогодні, "завтра", "післязавтра", "щойно" - також поверни відповідний час події в "time".

    ###Якщо користувач не вказав "о (або в) *конкретний час*###:
    action: "-", якщо користувач говорить про минуле, або "+", якщо про майбутнє;
    Поля "years", "months", "days", "hours", "minutes" визнач згідно тексту користувача й вкажи INT значення для відповідних ключів.
    Наприклад:
    Користувач: " 3 дні 17 хвилин тому"
    Відповідь:
    {{"time": null,
    "action": "-",
    "years": null,
    "months": null,
    "days": 3,
    "hours": null,
    "minutes":17}}


    Наприклад:
    Користувач: "через 12 хвилин"
    Відповідь:
    {{"time": null,
    "action": "+",
    "years": null,
    "months": null,
    "days": null,
    "hours": null,
    "minutes":12}}

    '''
    return prompt

